---
title: "MCMC test2"
author: "Natalie Morse"
date: "May 27, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
trueA <- 5
trueB <- 0
trueSd <- 10
sampleSize <- 31
 
# create independent x-values 
x <- (-(sampleSize-1)/2):((sampleSize-1)/2)
# create dependent values according to ax + b + N(0,sd)
y <-  trueA * x + trueB + rnorm(n=sampleSize,mean=0,sd=trueSd)
 
plot(x,y, main="Test Data")
```

```{r}
likelihood <- function(param){
    a = param[1]
    b = param[2]
    sd = param[3]
    pred = a*x + b
    singlelikelihoods = dnorm(y, mean = pred, sd = sd, log = T)
    sumll = sum(singlelikelihoods)
    return(sumll)   
}
 
paramtest=c(1,2,3)
likelihood(paramtest)
 a = paramtest[1]
    b = paramtest[2]
    sd = paramtest[3]
    pred = a*x + b
    dnorm(y, mean = pred, sd = sd, log = T)
```

```{r}
# Prior distribution
prior <- function(param){
    a = param[1]
    b = param[2]
    sd = param[3]
    aprior = dunif(a, min=0, max=10, log = T)
    bprior = dnorm(b, sd = 5, log = T)
    sdprior = dunif(sd, min=0, max=30, log = T)
    return(aprior+bprior+sdprior)
}

prior(paramtest)
```

```{r}
posterior <- function(param){
   return (likelihood(param) + prior(param))
}

posterior=function(param){
    a = param[1]
    b = param[2]
    sd = param[3]
    pred = a*x + b
    singlelikelihoods = dnorm(y, mean = pred, sd = sd, log = T)
    sumll = sum(singlelikelihoods) #likelihoods
    aprior = dunif(a, min=0, max=10, log = T)#oriors
    bprior = dnorm(b, sd = 5, log = T)
    sdprior = dunif(sd, min=0, max=30, log = T)
    return(sumll)+return(aprior+bprior+sdprior) #sum them up when in log form
}
```


```{r}
######## Metropolis algorithm ################
 
proposalfunction <- function(param){
    return(rnorm(3,mean = param, sd= c(0.1,0.5,0.3)))
}
 
run_metropolis_MCMC <- function(startvalue, iterations){
    chain = array(dim = c(iterations+1,3))
    chain[1,] = startvalue
    for (i in 1:iterations){
        proposal = proposalfunction(chain[i,])
         
        probab = exp(posterior(proposal) - posterior(chain[i,]))
        if (runif(1) < probab){
            chain[i+1,] = proposal
        }else{
            chain[i+1,] = chain[i,]
        }
    }
    return(chain)
}
 
startvalue = c(4,0,10)
chain = run_metropolis_MCMC(startvalue, 10000)
 
burnIn = 5000
acceptance = 1-mean(duplicated(chain[-(1:burnIn),]))

#hist(chain)
```

```{r}
xx=run_metropolis_MCMC(9,100)
```


------------------ my try

```{r}
trueA <- 12 #mean of size
trueSd <- 2
sampleSize <- 50
 
# create independent x-values 
x <- (-(sampleSize-1)/2):((sampleSize-1)/2)
# create dependent values according to ax + b + N(0,sd)
y <-  rnorm(n=sampleSize,mean=trueA,sd=trueSd)
 
plot(x,y, main="Test Data")
```

```{r}
likelihood <- function(param){
    a = param[1]
    sd = param[3]
     
    pred = rnorm(n=sampleSize, mean=a, sd=sd)
    singlelikelihoods = dnorm(y, mean = pred, sd = sd, log = T)
    sumll = sum(singlelikelihoods)
    return(sumll)   
}
 
#test this out
paramtest=c(1,2)
param=c(1,2)
likelihood(paramtest)
 a = paramtest[1]
    sd = paramtest[2]
     pred = rnorm(n=sampleSize, mean=a, sd=sd)
    dnorm(y, mean = pred, sd = sd, log = T)
```

```{r}
# Prior distribution
prior <- function(param){
    a = param[1]
    sd = param[2]
    aprior = dunif(a, min=0, max=10, log = T)
    sdprior = dunif(sd, min=0, max=30, log = T)
    return(aprior+sdprior)
}
```

```{r}
posterior <- function(param){
   return (likelihood(param) + prior(param))
}
```


```{r}
######## Metropolis algorithm ################
 
proposalfunction <- function(param){
    return(rnorm(2,mean = param, sd= c(0.1,0.5)))
}
 
run_metropolis_MCMC <- function(startvalue, iterations){
    chain = array(dim = c(iterations+1,3))
    chain[1,] = startvalue
    for (i in 1:iterations){
        proposal = proposalfunction(chain[i,])
         
        probab = exp(posterior(proposal) - posterior(chain[i,]))
        if (runif(1) < probab){
            chain[i+1,] = proposal
        }else{
            chain[i+1,] = chain[i,]
        }
    }
    return(chain)
}
 
startvalue = c(4,0,10)
chain = run_metropolis_MCMC(startvalue, 10000)
 
burnIn = 5000
acceptance = 1-mean(duplicated(chain[-(1:burnIn),]))

#hist(chain)
```

```{r}
run_metropolis_MCMC(9,100)
```


http://sbfnk.github.io/mfiidd/mcmc_example.html
```{r}
# This is a function that takes four parameters:
# - target: the target distribution, a function that takes one
#   argument (a number) and returns the (logged) value of a
#   distribution
# - init.theta: the initial value of theta, a number
# - proposal.sd: the standard deviation of (Gaussian) proposal
#   distribution
# - n.iterations: the number of iterations
# The function returns a vector of samples of theta from the target
# distribution

target.norm=function(x) (dnorm(x=x, mean=8, sd=1, log=T))#target funcion is normal with mean=8, sd=1 evaluate at proposed thetas. evaluate will give probabiliy of observing that value given the target distribution
my_mcmcMH <- function(target, init.theta, proposal.sd, n.iterations) {

    # evaluate the function "target" at "init.theta", and assign to
    # a variable called target.theta.current.
    target.theta.current <- target(init.theta)

    # initialise variables to store the current value of theta, the
    # vector of samples, and the number of accepted runs
    theta.current <- init.theta
    samples <- theta.current
    accepted <- 0

    # run MCMC for n.iteration interations
    for (i.iteration in seq_len(n.iterations)) {

        # draw a new theta from the (Gaussian) proposal distribution
        # and assign to a variable called theta.proposed.  
        # See "?rnorm for more information
        # Note that this step is vectorized for any arbitratry theta 
        # which will be useful when we will sample from a multivariate
        # target distribution
        theta.proposed <- rnorm(n = length(theta.current),
                                mean = theta.current,
                                sd = proposal.sd)

        # Note that 'rnorm' returns an unnamed vector, but the functions of
        # 'fitmodel' need a named parameter vector. We therefore set
        # the names of theta.proposed to be the same as the names of
        # theta.current
        names(theta.proposed) <- names(theta.current)

        # evaluate the function target at the proposed theta and
        # assign to a variable called target.theta.proposed
        target.theta.proposed <- target(theta.proposed)

        # compute Metropolis-Hastings ratio (acceptance probability). Since
        # the multivariate Gaussian is symmetric, we don't need to consider
        # the proposal distribution here
        log.acceptance <- target.theta.proposed - target.theta.current

        # draw random number number between 0 and 1 using "runif" and assign to
        # a variable called r.
        r <- runif(1)

        # test acceptance by comparing the random number to the
        # Metropolis-Hastings ratio (acceptance probability) (using
        # "exp" because we calculated the logarithm of the
        # Metropolis-Hastings ratio before)
        if (r < exp(log.acceptance)) {

            # if accepted:
            # change the current value of theta to the proposed theta
            theta.current <- theta.proposed

            # updated the current value of the target
            target.theta.current <- target.theta.proposed

            # update number of accepted proposals
            accepted <- accepted + 1
        }

        # add the current theta to the vector of samples
        # Note that we use `rbind` in order to deal with multivariate 
        # target. So if `theta` is a vector then `samples` is a matrix.
        samples <- rbind(samples, theta.current, deparse.level=0)

        # print current state of chain and acceptance rate
        # use paste() to deal with the case where `theta` is a vector
        message("iteration: ", i.iteration, ", chain:", paste(theta.current, collapse=" "),
                ", acceptance rate:", accepted / i.iteration)

    }

    # return the trace of the chain (i.e., the vector of samples)
    #return(samples)
}
```


```{r}
target.norm=function(x) (dnorm(x=x, mean=12, sd=4, log=T))#target funcion is normal with mean=8, sd=1 evaluate at proposed thetas. evaluate will give probabiliy of observing that value given the target distribution
my_output=my_mcmcMH(target=target.norm, init.theta=9, proposal.sd=2, n.iterations=2000)

hist(my_output)
```

```{r}
dnorm.log <- function(theta) {
   return(dnorm(x = theta, mean = 0, sd = 1))
}

dnorm.log(1)
```

```{r}
sum(my_output>15)/length(my_output)
```

